% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_m_eff.R
\name{calculate_m_eff}
\alias{calculate_m_eff}
\title{Compute inverse of 'solve_for_hiershrink_scale'}
\usage{
calculate_m_eff(
  scale,
  npar,
  local_dof = 1,
  global_dof = 1,
  slab_precision = (1/15)^2,
  n,
  n_sim = 2e+05
)
}
\arguments{
\item{scale}{(pos. real) the scale parameter, defined as c / sigma.}

\item{npar}{(pos. integers): the number of covariates.}

\item{local_dof}{(pos. integer) number indicating the degrees of freedom for
lambda_j. Boonstra and Barbaro always used local_dof = 1. Choose a negative
value to tell the function that there are no local hyperparameters.}

\item{global_dof}{(pos. integer) number indicating the degrees of freedom for
tau. Boonstra and Barbaro always used global_dof = 1. Choose a negative
value to tell the function that there is no global hyperparameter.}

\item{slab_precision}{(pos. real) the slab-part of the regularized horseshoe,
this is equivalent to (1/d)^2 in the notation of Boonstra and Barbaro}

\item{n}{sample size}

\item{n_sim}{number of simulates}
}
\value{
the implied number of effective parameters.
}
\description{
Instead of providing a desired effective number of parameters, the user provides
the scale value, which is c / sigma, in the notation of Boonstra and Barbaro, and the
function gives the implied prior number of effective parameters based upon this value.
}
