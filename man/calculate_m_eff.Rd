% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_m_eff.R
\name{calculate_m_eff}
\alias{calculate_m_eff}
\title{Compute inverse of 'solve_for_hiershrink_scale'}
\usage{
calculate_m_eff(scale1, scale2 = NA, npar1, npar2 = 0, local_dof = 1,
  regional_dof = -Inf, global_dof = 1, slab_precision = (1/15)^2, n,
  sigma = 2, tol = .Machine$double.eps^0.5, max_iter = 100,
  n_sim = 2e+05)
}
\arguments{
\item{scale1}{}

\item{scale2}{}

\item{npar1}{}

\item{npar2}{}

\item{local_dof}{}

\item{regional_dof}{}

\item{global_dof}{}

\item{slab_precision}{}

\item{n}{}

\item{sigma}{}

\item{tol}{}

\item{max_iter}{}

\item{n_sim}{}
}
\value{
list containing prior numbers 1 and 2
}
\description{
Instead of providing a desired effective number of parameters, the user provides 
the scale value(s), which is c in the notation of Boonstra and Barbaro, and the the 
function gives the implied prior number of effective parameters based upon this. 
As with 'solve_for_hiershrink_scale', the user can provide one global scale parameter 
(scale1, leaving scale2 = NA) that applies to all parameters, or two regional scale 
parameters (scale1, scale2), that applies to a partition of the parameters as 
defined by the first npar1 parameters and the second npar2 parameters.
}
